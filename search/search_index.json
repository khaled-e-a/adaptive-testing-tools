{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"adaptive-testing-tools","text":"<p>Adaptive random testing helpers for Python. Generate diverse candidates using a fixed-size candidate set (FSCs) selector plus a few lightweight random utilities.</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install adaptive-testing-tools\n</code></pre>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>from adaptive_testing_tools import adaptive_random_testing\nfrom random import Random\n\ndef make_candidate(rng: Random) -&gt; str:\n    return \"\".join(rng.choice(\"abc\") for _ in range(6))\n\ndef evaluate(candidate: str) -&gt; int:\n    return candidate.count(\"a\")\n\nsamples = adaptive_random_testing(\n    make_candidate,\n    evaluate,\n    pool_size=5,\n    max_iterations=3,\n    seed=42,\n)\nfor sample in samples:\n    print(sample.iteration, sample.candidate, sample.distance_to_previous, sample.result)\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Adaptive Random Testing with FSCs selection.</li> <li>Configurable distance function (defaults to Levenshtein with rapidfuzz fallback).</li> <li>Simple random helpers: ints, choice, strings.</li> </ul> <p>See the API reference (from the menu) for details.</p>"},{"location":"api/","title":"API Reference","text":"<p>General-purpose Adaptive Random Testing helpers.</p> <p>Utilities for generating small random values for tests.</p>"},{"location":"api/#adaptive_testing_tools.adaptive.adaptive_random_testing","title":"adaptive_random_testing","text":"<pre><code>adaptive_random_testing(generate_candidate: Callable[[Random], str], evaluate: Callable[[str], R], *, pool_size: int = 10, max_iterations: int = 5, seed: Optional[int] = None, distance_fn: Callable[[str, str], int] = levenshtein_distance) -&gt; List[AdaptiveSample[R]]\n</code></pre> <p>Run Adaptive Random Testing using FSCs to spread out sampled inputs.</p> <p>Parameters:</p> Name Type Description Default <code>generate_candidate</code> <code>Callable[[Random], str]</code> <p>Callable that accepts a Random instance and returns an input to test.</p> required <code>evaluate</code> <code>Callable[[str], R]</code> <p>Callable invoked on each candidate; its return value is recorded.</p> required <code>pool_size</code> <code>int</code> <p>Number of candidates generated per iteration to select the farthest one.</p> <code>10</code> <code>max_iterations</code> <code>int</code> <p>Total samples to run.</p> <code>5</code> <code>seed</code> <code>Optional[int]</code> <p>Optional seed to make sampling repeatable.</p> <code>None</code> <code>distance_fn</code> <code>Callable[[str, str], int]</code> <p>Distance function used to measure spread between candidates.</p> <code>levenshtein_distance</code> <p>Returns:</p> Type Description <code>List[AdaptiveSample[R]]</code> <p>A list of AdaptiveSample entries containing the candidate, distance to prior inputs,</p> <code>List[AdaptiveSample[R]]</code> <p>and the evaluation result.</p> Source code in <code>src/adaptive_testing_tools/adaptive.py</code> <pre><code>def adaptive_random_testing(\n    generate_candidate: Callable[[random.Random], str],\n    evaluate: Callable[[str], R],\n    *,\n    pool_size: int = 10,\n    max_iterations: int = 5,\n    seed: Optional[int] = None,\n    distance_fn: Callable[[str, str], int] = levenshtein_distance,\n) -&gt; List[AdaptiveSample[R]]:\n    \"\"\"\n    Run Adaptive Random Testing using FSCs to spread out sampled inputs.\n\n    Args:\n        generate_candidate: Callable that accepts a Random instance and returns an input to test.\n        evaluate: Callable invoked on each candidate; its return value is recorded.\n        pool_size: Number of candidates generated per iteration to select the farthest one.\n        max_iterations: Total samples to run.\n        seed: Optional seed to make sampling repeatable.\n        distance_fn: Distance function used to measure spread between candidates.\n\n    Returns:\n        A list of AdaptiveSample entries containing the candidate, distance to prior inputs,\n        and the evaluation result.\n    \"\"\"\n    rng = random.Random(seed)\n    tested: List[str] = []\n    samples: List[AdaptiveSample] = []\n\n    for iteration in range(1, max_iterations + 1):\n        candidate = select_fscs_candidate(\n            tested,\n            lambda: generate_candidate(rng),\n            pool_size=pool_size,\n            distance_fn=distance_fn,\n        )\n        result = evaluate(candidate)\n        distance = (\n            min(distance_fn(candidate, seen) for seen in tested) if tested else None\n        )\n        tested.append(candidate)\n        samples.append(\n            AdaptiveSample(\n                iteration=iteration,\n                candidate=candidate,\n                result=result,\n                distance_to_previous=distance,\n            )\n        )\n    return samples\n</code></pre>"},{"location":"api/#adaptive_testing_tools.adaptive.levenshtein_distance","title":"levenshtein_distance","text":"<pre><code>levenshtein_distance(a: str, b: str) -&gt; int\n</code></pre> <p>Return Levenshtein edit distance using rapidfuzz when available.</p> Source code in <code>src/adaptive_testing_tools/adaptive.py</code> <pre><code>def levenshtein_distance(a: str, b: str) -&gt; int:\n    \"\"\"Return Levenshtein edit distance using rapidfuzz when available.\"\"\"\n    if _Levenshtein is not None:\n        return int(_Levenshtein.distance(a, b))\n    return _python_levenshtein(a, b)\n</code></pre>"},{"location":"api/#adaptive_testing_tools.adaptive.select_fscs_candidate","title":"select_fscs_candidate","text":"<pre><code>select_fscs_candidate(previous: Sequence[str], generate_candidate: Callable[[], str], *, pool_size: int = 10, distance_fn: Callable[[str, str], int] = levenshtein_distance) -&gt; str\n</code></pre> <p>Pick the candidate with the largest minimum distance to prior samples (FSCs).</p> <p>FSCs = Fixed Size Candidate Set. A pool of random candidates is generated and the one farthest from all previously tested inputs is selected.</p> Source code in <code>src/adaptive_testing_tools/adaptive.py</code> <pre><code>def select_fscs_candidate(\n    previous: Sequence[str],\n    generate_candidate: Callable[[], str],\n    *,\n    pool_size: int = 10,\n    distance_fn: Callable[[str, str], int] = levenshtein_distance,\n) -&gt; str:\n    \"\"\"\n    Pick the candidate with the largest minimum distance to prior samples (FSCs).\n\n    FSCs = Fixed Size Candidate Set. A pool of random candidates is generated and\n    the one farthest from all previously tested inputs is selected.\n    \"\"\"\n    if not previous:\n        return generate_candidate()\n    best_candidate: Optional[str] = None\n    best_distance = -1\n    for _ in range(pool_size):\n        candidate = generate_candidate()\n        distance = min(distance_fn(candidate, seen) for seen in previous)\n        if distance &gt; best_distance:\n            best_candidate = candidate\n            best_distance = distance\n    return best_candidate if best_candidate is not None else generate_candidate()\n</code></pre>"},{"location":"api/#adaptive_testing_tools.generator.random_choice","title":"random_choice","text":"<pre><code>random_choice(options: Sequence[T]) -&gt; T\n</code></pre> <p>Return a random element from a non-empty sequence.</p> Source code in <code>src/adaptive_testing_tools/generator.py</code> <pre><code>def random_choice(options: Sequence[T]) -&gt; T:\n    \"\"\"Return a random element from a non-empty sequence.\"\"\"\n    if not options:\n        raise ValueError(\"options must not be empty\")\n    return random.choice(options)\n</code></pre>"},{"location":"api/#adaptive_testing_tools.generator.random_int","title":"random_int","text":"<pre><code>random_int(low: int = 0, high: int = 100) -&gt; int\n</code></pre> <p>Return a random integer between low and high (inclusive).</p> Source code in <code>src/adaptive_testing_tools/generator.py</code> <pre><code>def random_int(low: int = 0, high: int = 100) -&gt; int:\n    \"\"\"Return a random integer between low and high (inclusive).\"\"\"\n    return random.randint(low, high)\n</code></pre>"},{"location":"api/#adaptive_testing_tools.generator.random_string","title":"random_string","text":"<pre><code>random_string(length: int = 8, alphabet: Iterable[str] = None) -&gt; str\n</code></pre> <p>Return a random string of the given length.</p> Source code in <code>src/adaptive_testing_tools/generator.py</code> <pre><code>def random_string(length: int = 8, alphabet: Iterable[str] = None) -&gt; str:\n    \"\"\"Return a random string of the given length.\"\"\"\n    if length &lt; 0:\n        raise ValueError(\"length must be non-negative\")\n    chars = alphabet or (string.ascii_letters + string.digits)\n    return \"\".join(random.choice(chars) for _ in range(length))\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#adaptive-random-testing","title":"Adaptive Random Testing","text":"<p>Use <code>adaptive_random_testing</code> with two callables:</p> <ul> <li><code>generate_candidate(rng: Random) -&gt; str</code>: produce an input.</li> <li><code>evaluate(candidate: str) -&gt; Any</code>: run your system-under-test and return a result to record.</li> </ul> <pre><code>from random import Random\nfrom adaptive_testing_tools import adaptive_random_testing, levenshtein_distance\n\ndef generate_candidate(rng: Random) -&gt; str:\n    return \" \".join(rng.sample([\"alpha\", \"bravo\", \"charlie\", \"delta\"], 3))\n\ndef evaluate(candidate: str) -&gt; bool:\n    return \"alpha\" in candidate\n\nsamples = adaptive_random_testing(\n    generate_candidate,\n    evaluate,\n    pool_size=5,\n    max_iterations=5,\n    seed=123,\n    distance_fn=levenshtein_distance,\n)\nfor sample in samples:\n    print(sample.iteration, sample.distance_to_previous, sample.result)\n</code></pre>"},{"location":"usage/#random-helpers","title":"Random helpers","text":"<pre><code>from adaptive_testing_tools import random_choice, random_int, random_string\n\nprint(random_int(1, 10))\nprint(random_choice([\"x\", \"y\", \"z\"]))\nprint(random_string(8))\n</code></pre>"}]}